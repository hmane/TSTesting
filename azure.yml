# azure-pipelines.yml - Main Pipeline for Build, Scan, and Publish
trigger:
  branches:
    include:
    - dev
    - uat
    - prod
  paths:
    exclude:
    - README.md
    - docs/*

parameters:
- name: runVeracodeScan
  displayName: 'Run Veracode Scan'
  type: boolean
  default: false

variables:
  buildConfiguration: 'Release'
  dotnetFrameworkVersion: 'v4.7.2'
  nugetFeedId: 'your-feed-id-here' # Replace with your actual feed ID
  appProfileName: 'YourAppProfile' # Replace with your Veracode app profile name
  # Container configuration
  containerImage: 'your-container-registry/dotnet-framework-build:latest' # Replace with your container image
  containerEndpoint: 'your-container-endpoint' # Replace with your container registry service connection
  poolName: 'your-pool-name' # Replace with your agent pool name
  # File paths
  solutionPath: 'YourSolution.sln' # Replace with your solution file path
  mainProjectPath: 'src/MainProject/MainProject.csproj' # Replace with your main project path (for NuGet and Veracode)
  # Version suffix based on branch
  versionSuffix: ${{ 
    eq(variables['Build.SourceBranchName'], 'uat') and '-beta' or
    (eq(variables['Build.SourceBranchName'], 'prod') and '' or '-dev') }}

stages:
- stage: Build
  displayName: 'Build Stage'
  jobs:
  - job: BuildJob
    displayName: 'Build .NET Framework Application'
    pool:
      name: $(poolName)
    container:
      image: $(containerImage)
      endpoint: $(containerEndpoint)
      options: --user root
    steps:
    - checkout: self
      fetchDepth: 1

    # Get project version for Veracode scan naming
    - task: PowerShell@2
      displayName: 'Extract Project Version'
      name: 'ExtractVersion'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Extracting project version from: $(mainProjectPath)"
          
          $projectFile = "$(Build.SourcesDirectory)/$(mainProjectPath)"
          
          if (-not (Test-Path $projectFile)) {
              throw "Project file not found: $projectFile"
          }
          
          Write-Host "Found project file: $projectFile"
          
          # Read and parse the project file
          [xml]$projectXml = Get-Content $projectFile
          
          # Try to get version from various possible locations
          $version = $null
          
          # Check for Version element
          if ($projectXml.Project.PropertyGroup.Version) {
              $version = $projectXml.Project.PropertyGroup.Version
          }
          # Check for AssemblyVersion
          elseif ($projectXml.Project.PropertyGroup.AssemblyVersion) {
              $version = $projectXml.Project.PropertyGroup.AssemblyVersion
          }
          # Default version if not found
          else {
              $version = "1.0.0"
              Write-Warning "No version found in project file, using default: $version"
          }
          
          Write-Host "Project version: $version"
          Write-Host "##vso[task.setvariable variable=ProjectVersion;isOutput=true]$version"
          
          # Create Veracode scan version name: AppProfileName_Version_BuildNumber
          $scanVersion = "$(appProfileName)_${version}_$(Build.BuildNumber)"
          Write-Host "Veracode scan version: $scanVersion"
          Write-Host "##vso[task.setvariable variable=VeracodeScanVersion;isOutput=true]$scanVersion"

    # Install required tools in container (if not already present)
    - task: PowerShell@2
      displayName: 'Setup Build Environment'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Setting up build environment in container..."
          
          # Check if running in Linux container
          if ($PSVersionTable.Platform -eq "Unix") {
              Write-Host "Detected Linux container environment"
              
              # Install wine and related tools for .NET Framework builds on Linux
              apt-get update
              apt-get install -y wget software-properties-common
              
              # Add Microsoft package repository
              wget -q https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb
              dpkg -i packages-microsoft-prod.deb
              apt-get update
              
              # Install .NET Framework targeting pack and build tools
              apt-get install -y mono-complete msbuild nuget
              
              Write-Host "Linux build environment setup complete"
          } else {
              Write-Host "Detected Windows container environment"
              # Windows container - tools should already be available
          }

    # Restore NuGet packages
    - task: NuGetToolInstaller@1
      displayName: 'Install NuGet Tool'
      inputs:
        versionSpec: 'latest'

    - task: NuGetCommand@2
      displayName: 'Restore NuGet Packages'
      inputs:
        restoreSolution: '$(solutionPath)'
        feedsToUse: 'select'

    # Build the solution using MSBuild@1
    - task: MSBuild@1
      displayName: 'Build Solution'
      inputs:
        solution: '$(solutionPath)'
        msbuildArchitecture: 'x64'
        platform: 'Any CPU'
        configuration: '$(buildConfiguration)'

    # Create build artifact for Veracode scanning (main project only)
    - task: PowerShell@2
      displayName: 'Prepare Veracode Scan Artifact'
      name: 'PrepareVeracode'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Preparing Veracode scan artifact for main project..."
          
          # Get the directory of the main project
          $projectFile = "$(Build.SourcesDirectory)/$(mainProjectPath)"
          $projectDir = Split-Path $projectFile -Parent
          
          Write-Host "Main project directory: $projectDir"
          
          # Find build outputs for the main project only
          $buildOutputs = Get-ChildItem -Path $projectDir -Recurse -Include "*.dll", "*.exe", "*.pdb" | Where-Object { 
              $_.FullName -like "*bin*$(buildConfiguration)*" -or $_.FullName -like "*bin/$(buildConfiguration)*" 
          }
          
          if ($buildOutputs.Count -eq 0) {
              throw "No build outputs found for main project in Veracode scanning"
          }
          
          Write-Host "Files for Veracode scan: $($buildOutputs.Count)"
          foreach ($file in $buildOutputs) {
              Write-Host "  - $($file.Name)"
          }
          
          # Create temp directory for veracode scan
          $veracodeDir = "$(Build.ArtifactStagingDirectory)/VeracodeScan"
          New-Item -ItemType Directory -Path $veracodeDir -Force
          
          # Copy build outputs
          foreach ($file in $buildOutputs) {
              $destinationPath = Join-Path $veracodeDir $file.Name
              Copy-Item $file.FullName -Destination $destinationPath -Force
              Write-Host "Copied: $($file.Name)"
          }
          
          # Get the scan version from previous step
          $scanVersion = "$(ExtractVersion.VeracodeScanVersion)"
          
          # Create zip file for Veracode with proper naming: AppProfileName_Version_BuildNumber
          $zipFileName = "$scanVersion.zip"
          $zipPath = "$(Build.ArtifactStagingDirectory)/$zipFileName"
          
          Write-Host "Creating zip file: $zipFileName"
          
          # Check if running in Linux container
          if ($PSVersionTable.Platform -eq "Unix") {
              # Use system zip command on Linux
              Set-Location $veracodeDir
              & zip -r $zipPath *
              Set-Location "$(Build.SourcesDirectory)"
          } else {
              # Use PowerShell Compress-Archive on Windows
              Compress-Archive -Path "$veracodeDir/*" -DestinationPath $zipPath -Force
          }
          
          Write-Host "Created Veracode scan package: $zipPath"
          
          # Verify zip file was created
          if (Test-Path $zipPath) {
              $zipSize = (Get-Item $zipPath).Length
              Write-Host "Zip file size: $([math]::Round($zipSize / 1MB, 2)) MB"
              Write-Host "##vso[task.setvariable variable=VeracodeZipFileName;isOutput=true]$zipFileName"
          } else {
              throw "Failed to create Veracode zip file"
          }

    # Pack NuGet package with version suffix (main project only)
    - task: PowerShell@2
      displayName: 'Determine Package Version'
      inputs:
        targetType: 'inline'
        script: |
          # Get project version from previous step
          $projectVersion = "$(ExtractVersion.ProjectVersion)"
          
          # Determine version with suffix
          $packageVersion = $projectVersion
          if ("$(versionSuffix)" -ne "") {
              $packageVersion += "$(versionSuffix).$(Build.BuildNumber)"
          } else {
              $packageVersion += ".$(Build.BuildNumber)"
          }
          
          Write-Host "Package version will be: $packageVersion"
          Write-Host "##vso[task.setvariable variable=PackageVersion]$packageVersion"

    - task: NuGetCommand@2
      displayName: 'Pack NuGet Package'
      inputs:
        command: 'pack'
        packagesToPack: '$(mainProjectPath)'
        configuration: '$(buildConfiguration)'
        packDestination: '$(Build.ArtifactStagingDirectory)/packages'
        versioningScheme: 'byEnvVar'
        versionEnvVar: 'PackageVersion'

    # Publish build artifacts (including the named Veracode zip)
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Build Artifacts'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)'
        artifactName: 'BuildOutputs'

- stage: SecurityScan
  displayName: 'Veracode Security Scan'
  dependsOn: Build
  condition: and(succeeded(), or(eq('${{ parameters.runVeracodeScan }}', true), eq(variables['Build.SourceBranchName'], 'uat')))
  variables:
    VeracodeScanVersion: $[ stageDependencies.Build.BuildJob.outputs['ExtractVersion.VeracodeScanVersion'] ]
    VeracodeZipFileName: $[ stageDependencies.Build.BuildJob.outputs['PrepareVeracode.VeracodeZipFileName'] ]
  jobs:
  - job: VeracodeScan
    displayName: 'Submit to Veracode'
    pool:
      name: $(poolName)
    container:
      image: $(containerImage)
      endpoint: $(containerEndpoint)
      options: --user root
    steps:
    - checkout: none
    
    - task: DownloadBuildArtifacts@0
      displayName: 'Download Build Artifacts'
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: 'BuildOutputs'
        downloadPath: '$(System.ArtifactsDirectory)'

    # Submit to Veracode using the official task
    - task: Veracode@3
      displayName: 'Submit to Veracode Scan'
      inputs:
        ConnectionDetailsSelection: 'Service Connection'
        AnalysisService: 'your-veracode-service-connection'  # Replace with your actual service connection name
        veracodeAppProfile: '$(appProfileName)'
        version: '$(VeracodeScanVersion)'
        filepath: '$(System.ArtifactsDirectory)/BuildOutputs/$(VeracodeZipFileName)'
        createProfile: false
        failBuildIfUploadAndScanBuildStepFails: true
        importResults: false
        failBuildOnPolicyFail: false

    # Generate scan summary
    - task: PowerShell@2
      displayName: 'Generate Scan Summary'
      condition: always()
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "=== Veracode Scan Summary ==="
          Write-Host "Application Profile: $(appProfileName)"
          Write-Host "Scan Version: $(VeracodeScanVersion)"
          Write-Host "Zip File: $(VeracodeZipFileName)"
          Write-Host ""
          Write-Host "Check the Veracode platform for scan results:"
          Write-Host "https://analysiscenter.veracode.com/auth/index.jsp"

- stage: Publish
  displayName: 'Publish NuGet Package'
  dependsOn: 
  - Build
  - SecurityScan
  condition: and(succeeded(), or(succeeded('SecurityScan'), eq('${{ parameters.runVeracodeScan }}', false)))
  jobs:
  - job: PublishJob
    displayName: 'Publish to Azure Artifacts'
    pool:
      name: $(poolName)
    container:
      image: $(containerImage)
      endpoint: $(containerEndpoint)
      options: --user root
    steps:
    - checkout: none
    
    - task: DownloadBuildArtifacts@0
      displayName: 'Download Build Artifacts'
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: 'BuildOutputs'
        downloadPath: '$(System.ArtifactsDirectory)'

    - task: NuGetCommand@2
      displayName: 'Push NuGet Package'
      inputs:
        command: 'push'
        packagesToPush: '$(System.ArtifactsDirectory)/BuildOutputs/packages/*.nupkg'
        nuGetFeedType: 'internal'
        publishVstsFeed: '$(nugetFeedId)'
