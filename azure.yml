# azure-pipelines.yml - Main Pipeline for Build, Scan, and Publish
trigger:
  branches:
    include:
    - dev
    - uat
    - prod
  paths:
    exclude:
    - README.md
    - docs/*

parameters:
- name: runVeracodeScan
  displayName: 'Run Veracode Scan'
  type: boolean
  default: false

variables:
  buildConfiguration: 'Release'
  dotnetFrameworkVersion: 'v4.7.2'
  nugetFeedId: 'your-feed-id-here' # Replace with your actual feed ID
  appProfileName: 'YourAppProfile' # Replace with your Veracode app profile name
  # Container configuration
  containerImage: 'your-container-registry/dotnet-framework-build:latest' # Replace with your container image
  containerEndpoint: 'your-container-endpoint' # Replace with your container registry service connection
  poolName: 'your-pool-name' # Replace with your agent pool name
  # File paths
  solutionPath: 'YourSolution.sln' # Replace with your solution file path
  mainProjectPath: 'src/MainProject/MainProject.csproj' # Replace with your main project path (for NuGet and Veracode)

stages:
- stage: Build
  displayName: 'Build Stage'
  jobs:
  - job: BuildJob
    displayName: 'Build .NET Framework Application'
    pool:
      name: $(poolName)
    container:
      image: $(containerImage)
      endpoint: $(containerEndpoint)
      options: --user root
    steps:
    - checkout: self
      fetchDepth: 1

    # Determine version suffix based on branch
    - task: PowerShell@2
      displayName: 'Determine Version Suffix'
      name: 'DetermineVersionSuffix'
      inputs:
        targetType: 'inline'
        script: |
          $branchName = "$(Build.SourceBranchName)"
          Write-Host "Current branch: $branchName"
          
          # Determine version suffix based on branch
          if ($branchName -eq "uat") {
              $versionSuffix = "-beta"
          } elseif ($branchName -eq "prod") {
              $versionSuffix = ""
          } else {
              $versionSuffix = "-dev"
          }
          
          Write-Host "Version suffix: '$versionSuffix'"
          Write-Host "##vso[task.setvariable variable=VersionSuffix;isOutput=true]$versionSuffix"

    # Get project version for Veracode scan naming
    - task: PowerShell@2
      displayName: 'Extract Project Version'
      name: 'ExtractVersion'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Extracting project version from: $(mainProjectPath)"
          
          # Normalize path separators for cross-platform compatibility
          $projectPath = "$(mainProjectPath)".Replace('\', '/')
          $projectFile = Join-Path "$(Build.SourcesDirectory)" $projectPath
          
          if (-not (Test-Path $projectFile)) {
              throw "Project file not found: $projectFile"
          }
          
          Write-Host "Found project file: $projectFile"
          
          # Read and parse the project file
          [xml]$projectXml = Get-Content $projectFile
          
          # Try to get version from various possible locations
          $version = $null
          
          # Check for Version element
          if ($projectXml.Project.PropertyGroup.Version) {
              $version = $projectXml.Project.PropertyGroup.Version
          }
          # Check for AssemblyVersion
          elseif ($projectXml.Project.PropertyGroup.AssemblyVersion) {
              $version = $projectXml.Project.PropertyGroup.AssemblyVersion
          }
          # Default version if not found
          else {
              $version = "1.0.0"
              Write-Warning "No version found in project file, using default: $version"
          }
          
          Write-Host "Project version: $version"
          Write-Host "##vso[task.setvariable variable=ProjectVersion;isOutput=true]$version"
          
          # Create Veracode scan version name: AppProfileName_Version_BuildNumber
          $scanVersion = "$(appProfileName)_${version}_$(Build.BuildNumber)"
          Write-Host "Veracode scan version: $scanVersion"
          Write-Host "##vso[task.setvariable variable=VeracodeScanVersion;isOutput=true]$scanVersion"

    # Install required tools in container (if not already present)
    - task: PowerShell@2
      displayName: 'Setup Build Environment'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Setting up build environment in container..."
          
          # Check if running in Linux container
          if ($PSVersionTable.Platform -eq "Unix") {
              Write-Host "Detected Linux container environment"
              
              # Install wine and related tools for .NET Framework builds on Linux
              apt-get update
              apt-get install -y wget software-properties-common
              
              # Add Microsoft package repository
              wget -q https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb
              dpkg -i packages-microsoft-prod.deb
              apt-get update
              
              # Install .NET Framework targeting pack and build tools
              apt-get install -y mono-complete msbuild nuget
              
              Write-Host "Linux build environment setup complete"
          } else {
              Write-Host "Detected Windows container environment"
              # Windows container - tools should already be available
          }

    # Restore NuGet packages
    - task: PowerShell@2
      displayName: 'Restore NuGet Packages'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Restoring NuGet packages..."
          
          # Check if running in Linux container
          if ($PSVersionTable.Platform -eq "Unix") {
              # Use nuget restore on Linux
              & nuget restore "$(solutionPath)"
          } else {
              # Use NuGet task on Windows - install tool first if needed
              if (!(Get-Command nuget -ErrorAction SilentlyContinue)) {
                  Write-Host "Installing NuGet tool..."
                  # NuGet should be available in Windows containers
              }
              & nuget restore "$(solutionPath)"
          }
          
          if ($LASTEXITCODE -ne 0) {
              throw "NuGet restore failed with exit code $LASTEXITCODE"
          }
          
          Write-Host "NuGet restore completed successfully"

    # Build the solution (container-aware)
    - task: PowerShell@2
      displayName: 'Build Solution'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Building solution: $(solutionPath)"
          
          $solutionFile = "$(Build.SourcesDirectory)/$(solutionPath)"
          
          if (-not (Test-Path $solutionFile)) {
              throw "Solution file not found: $solutionFile"
          }
          
          # Check if running in Linux container
          if ($PSVersionTable.Platform -eq "Unix") {
              Write-Host "Building with MSBuild on Linux..."
              
              # Use msbuild for Linux
              $buildArgs = @(
                  $solutionFile,
                  "/p:Configuration=$(buildConfiguration)",
                  "/p:Platform=`"Any CPU`"",
                  "/verbosity:minimal"
              )
              
              & msbuild @buildArgs
              
          } else {
              Write-Host "Building with MSBuild on Windows..."
              
              # Use MSBuild for Windows
              $buildArgs = @(
                  $solutionFile,
                  "/p:Configuration=$(buildConfiguration)",
                  "/p:Platform=`"Any CPU`"",
                  "/verbosity:minimal"
              )
              
              & MSBuild @buildArgs
          }
          
          if ($LASTEXITCODE -ne 0) {
              throw "Build failed with exit code $LASTEXITCODE"
          }
          
          Write-Host "Build completed successfully!"

    # Create build artifact for Veracode scanning (main project only)
    - task: PowerShell@2
      displayName: 'Prepare Veracode Scan Artifact'
      name: 'PrepareVeracode'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Preparing Veracode scan artifact for main project..."
          
          # Normalize path separators and get the directory of the main project
          $projectPath = "$(mainProjectPath)".Replace('\', '/')
          $projectFile = Join-Path "$(Build.SourcesDirectory)" $projectPath
          $projectDir = Split-Path $projectFile -Parent
          
          Write-Host "Main project directory: $projectDir"
          
          # Find build outputs for the main project only
          $buildOutputs = Get-ChildItem -Path $projectDir -Recurse -Include "*.dll", "*.exe", "*.pdb" | Where-Object { 
              $_.FullName -like "*bin*$(buildConfiguration)*" -or $_.FullName -like "*bin/$(buildConfiguration)*" 
          }
          
          if ($buildOutputs.Count -eq 0) {
              throw "No build outputs found for main project in Veracode scanning"
          }
          
          Write-Host "Files for Veracode scan: $($buildOutputs.Count)"
          foreach ($file in $buildOutputs) {
              Write-Host "  - $($file.Name)"
          }
          
          # Create temp directory for veracode scan
          $veracodeDir = "$(Build.ArtifactStagingDirectory)/VeracodeScan"
          New-Item -ItemType Directory -Path $veracodeDir -Force
          
          # Copy build outputs
          foreach ($file in $buildOutputs) {
              $destinationPath = Join-Path $veracodeDir $file.Name
              Copy-Item $file.FullName -Destination $destinationPath -Force
              Write-Host "Copied: $($file.Name)"
          }
          
          # Get the scan version from previous step
          $scanVersion = "$(ExtractVersion.VeracodeScanVersion)"
          
          # Create zip file for Veracode with proper naming: AppProfileName_Version_BuildNumber
          $zipFileName = "$scanVersion.zip"
          $zipPath = "$(Build.ArtifactStagingDirectory)/$zipFileName"
          
          Write-Host "Creating zip file: $zipFileName"
          
          # Check if running in Linux container
          if ($PSVersionTable.Platform -eq "Unix") {
              # Use system zip command on Linux
              Set-Location $veracodeDir
              & zip -r $zipPath *
              Set-Location "$(Build.SourcesDirectory)"
          } else {
              # Use PowerShell Compress-Archive on Windows
              Compress-Archive -Path "$veracodeDir/*" -DestinationPath $zipPath -Force
          }
          
          Write-Host "Created Veracode scan package: $zipPath"
          
          # Verify zip file was created
          if (Test-Path $zipPath) {
              $zipSize = (Get-Item $zipPath).Length
              Write-Host "Zip file size: $([math]::Round($zipSize / 1MB, 2)) MB"
              Write-Host "##vso[task.setvariable variable=VeracodeZipFileName;isOutput=true]$zipFileName"
          } else {
              throw "Failed to create Veracode zip file"
          }

    # Pack NuGet package with version suffix (main project only)
    - task: PowerShell@2
      displayName: 'Determine Package Version'
      inputs:
        targetType: 'inline'
        script: |
          # Get project version and version suffix from previous steps
          $projectVersion = "$(ExtractVersion.ProjectVersion)"
          $versionSuffix = "$(DetermineVersionSuffix.VersionSuffix)"
          
          # Determine version with suffix
          $packageVersion = $projectVersion
          if ($versionSuffix -ne "") {
              $packageVersion += "$versionSuffix.$(Build.BuildNumber)"
          } else {
              $packageVersion += ".$(Build.BuildNumber)"
          }
          
          Write-Host "Project version: $projectVersion"
          Write-Host "Version suffix: '$versionSuffix'"
          Write-Host "Package version will be: $packageVersion"
          Write-Host "##vso[task.setvariable variable=PackageVersion]$packageVersion"

    - task: PowerShell@2
      displayName: 'Pack NuGet Package'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Creating NuGet package for main project..."
          
          # Normalize path separators
          $projectPath = "$(mainProjectPath)".Replace('\', '/')
          $projectFile = Join-Path "$(Build.SourcesDirectory)" $projectPath
          $packageVersion = "$(PackageVersion)"
          
          Write-Host "Project file: $projectFile"
          Write-Host "Package version: $packageVersion"
          
          # Create packages directory
          $packagesDir = "$(Build.ArtifactStagingDirectory)/packages"
          New-Item -ItemType Directory -Path $packagesDir -Force
          
          # Check if running in Linux container
          if ($PSVersionTable.Platform -eq "Unix") {
              Write-Host "Packing with nuget on Linux..."
              & nuget pack $projectFile -Properties Configuration=$(buildConfiguration) -OutputDirectory $packagesDir -Version $packageVersion
          } else {
              Write-Host "Packing with dotnet on Windows..."
              & dotnet pack $projectFile --configuration $(buildConfiguration) --output $packagesDir -p:PackageVersion=$packageVersion
          }
          
          if ($LASTEXITCODE -ne 0) {
              throw "NuGet pack failed with exit code $LASTEXITCODE"
          }
          
          # List created packages
          $packages = Get-ChildItem -Path $packagesDir -Filter "*.nupkg"
          Write-Host "Created packages:"
          foreach ($package in $packages) {
              Write-Host "  - $($package.Name)"
          }
          
          if ($packages.Count -eq 0) {
              throw "No NuGet packages were created"
          }

    # Publish build artifacts (including the named Veracode zip)
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Build Artifacts'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)'
        artifactName: 'BuildOutputs'

- stage: SecurityScan
  displayName: 'Veracode Security Scan'
  dependsOn: Build
  condition: and(succeeded(), or(eq('${{ parameters.runVeracodeScan }}', true), eq(variables['Build.SourceBranchName'], 'uat')))
  variables:
    VeracodeScanVersion: $[ stageDependencies.Build.BuildJob.outputs['ExtractVersion.VeracodeScanVersion'] ]
    VeracodeZipFileName: $[ stageDependencies.Build.BuildJob.outputs['PrepareVeracode.VeracodeZipFileName'] ]
  jobs:
  - job: VeracodeScan
    displayName: 'Submit to Veracode'
    pool:
      name: $(poolName)
    container:
      image: $(containerImage)
      endpoint: $(containerEndpoint)
      options: --user root
    steps:
    - checkout: none
    
    - task: DownloadBuildArtifacts@0
      displayName: 'Download Build Artifacts'
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: 'BuildOutputs'
        downloadPath: '$(System.ArtifactsDirectory)'

    # Submit to Veracode using the official task
    - task: Veracode@3
      displayName: 'Submit to Veracode Scan'
      inputs:
        ConnectionDetailsSelection: 'Service Connection'
        AnalysisService: 'your-veracode-service-connection'  # Replace with your actual service connection name
        veracodeAppProfile: '$(appProfileName)'
        version: '$(VeracodeScanVersion)'
        filepath: '$(System.ArtifactsDirectory)/BuildOutputs/$(VeracodeZipFileName)'
        createProfile: false
        failBuildIfUploadAndScanBuildStepFails: true
        importResults: false
        failBuildOnPolicyFail: false

    # Generate scan summary
    - task: PowerShell@2
      displayName: 'Generate Scan Summary'
      condition: always()
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "=== Veracode Scan Summary ==="
          Write-Host "Application Profile: $(appProfileName)"
          Write-Host "Scan Version: $(VeracodeScanVersion)"
          Write-Host "Zip File: $(VeracodeZipFileName)"
          Write-Host ""
          Write-Host "Check the Veracode platform for scan results:"
          Write-Host "https://analysiscenter.veracode.com/auth/index.jsp"

- stage: Publish
  displayName: 'Publish NuGet Package'
  dependsOn: 
  - Build
  - SecurityScan
  condition: and(succeeded(), or(succeeded('SecurityScan'), eq('${{ parameters.runVeracodeScan }}', false)))
  jobs:
  - job: PublishJob
    displayName: 'Publish to Azure Artifacts'
    pool:
      name: $(poolName)
    container:
      image: $(containerImage)
      endpoint: $(containerEndpoint)
      options: --user root
    steps:
    - checkout: none
    
    - task: DownloadBuildArtifacts@0
      displayName: 'Download Build Artifacts'
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: 'BuildOutputs'
        downloadPath: '$(System.ArtifactsDirectory)'

    - task: NuGetCommand@2
      displayName: 'Push NuGet Package'
      inputs:
        command: 'push'
        packagesToPush: '$(System.ArtifactsDirectory)/BuildOutputs/packages/*.nupkg'
        nuGetFeedType: 'internal'
        publishVstsFeed: '$(nugetFeedId)'
